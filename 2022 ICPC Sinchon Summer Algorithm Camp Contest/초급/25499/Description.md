6x6 보드판에 다양한 높이의 블록을 배치.
블록을 쓰럳뜨려 주인공이 출발지에서 목적지까지 이동

(new Version 1차원임)
보드판은 (N + 1)개의 칸이 일렬로 나열된 구조. 
=> totalFieldSize = N + 1;

각각의 칸은 가로와 세로가 1 CM인 정사각형 모양.
왼쪽부터 차례로 0 ~ N의 번호를 부여.
#define YES  1
#define NO 0
FieldisFilled[totalFieldSize] = {0} => 0이상의 값이 들어가면 차있는것으로 관주함

각각의 칸에는 블록이 최대 한개 놓임.
세원진 블록은 가로와 세로가 각각 1CM이고 높이는 2CM이상임.
2 <= BlockHeightAt[filedLocation] 

각 블록의 높이는 1CM의 정수 배.

세워진 블록은 왼쪽이나 오른쪽으로 쓰러뜨릴 수 있음.
i번 칸에 높이가 k cm 인 블록이 있을 때, 이것으 왼쪽으로 쓰러뜨리려면 이 블록은 (i - k) ~ (i - 1)번째 칸을 덮게 되고
if (왼쪽으로 쓰러뜨리면)
{
    (i - k) ~ (i - 1) 번째의 칸을 덮을 수 있게함.
}
, 오른쪽으로 쓰러뜨리면 (i + 1) ~ (i + k)번째 칸을 덮는다. 
if (오른쪽으로 쓰러뜨리면)
{
    (i + 1) ~ (i + k) 번째의 칸을 덮을 수 있게함.
    if (쓰러뜨리지 못하는 큐브이면)
    {
        쓰러뜨린 큐브를 복구하고 쓰러뜨리지 못하는 큐브로 지정.
    }
}
블록이 덮이는 칸에 다른 블록이 없고 블록이 덮이는 칸이 모두 보드판에 존재하는 칸일 경우에만 그 블록을 쓰러뜨릴 수 있음. 쓰러뜨린 블록은 더 이사 움직일 수 없음.

0번 칸에는 높이가 1cm인 블록이 존재함. 주인공이 처음에 0번 칸 위에 있으며 주인공이 N번 칸에 도착하면 게임을 클리어할 수 있음. 

주인공은 게임을 시작하기 전에 몇 개의 블록을 미리 쓰러뜨릴 수 있다.

주인공이 있는 칸과 인접한 칸에 블록이 없는 경우, 주인공은 인접한 칸에 높이가 1 cm인 큐브 블록을 추가할 수 있다.

```c
#define YES  1
#define NO 0
#define pBlockonField (BlockHeightAt + i)

int *BlockHeightAt;
FieldisFilled[totalFieldSize] = {0};
scanf(totalFieldSize);

BlockHeightAt 메모리 할당.

for(int i = 0; i < totalFieldSize; i++>)
{
        => 입력과 동시에 쓰러뜨려서 시간을 잡음.

        scanf(%d, BlockHeightAt + i);
        단, 시작점에서 가장 가까운 블록은 항상 시작점쪽으로 쓰러뜨리게 함.
        그러나, 1칸을 삽입하고 바로 다음칸에 블록이 높이가 2이상이면 오른쪽으로 쓰러뜨리게 함. 

        칸이 비워있는 갯수를 다음 블록이 있는 경우와 그 다음
        블록이 있는 경우를 셈(총 세가지 셈)

        세가지 블록 중 가장 높은 블록을 선택함. 그 블록 중 쓰러뜨릴 수 있는지 여부를 셈.  

        쓰러뜨릴 수 있으면 쓰러뜨려서 칸을 체움. 만약 1 2 3 중 1번이 가장 크다고 하면 1번을 쓰러뜨리고 2번부터 다시 세 건물을 체킹함. 
        2번이 가장 크다고 하면 2번을 쓰러뜨리고 1번을 쓰러뜨릴 수 있는지 여부를 판단함. 3번부터 다시 건물을 체킹함.
        3번이 가장 크면 1번을 쓰러뜨릴 수 있는지 판단하고 4번째 건물을 추가로 받아 두 건물 중 더 큰 건물을 쓰러뜨림.

        if (왼쪽으로 쓰러뜨리면)
        {
            (i - k) ~ (i - 1) 번째의 칸을 덮을 수 있게함.
        }
         
        if (오른쪽으로 쓰러뜨리면)
        {
            (i + 1) ~ (i + k) 번째의 칸을 덮을 수 있게함.
        }
        if (쓰러뜨리지 못하는 큐브이면)
        {
            쓰러뜨린 큐브를 복구하고 쓰러뜨리지 못하는 큐브로 지정.
        }
        

        if(*pBlockonField)
        {
            FieldisFilled[i] = 1;
            높이를 세서 i번째 
        }
}

=> 남은 칸 세기
for (int i )
{
    => 칸수를 셀 때 차있으면 BlockHeightAt 변수를 통해 길이를 파악해서 i값을 변경시켜서 더 빠르게 for문이 돌도록 유도시킴. 
}
```